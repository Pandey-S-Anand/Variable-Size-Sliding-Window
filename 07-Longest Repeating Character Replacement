//Bruteforce Approach

class Solution {
    public int characterReplacement(String str, int k) {
        // frequencyArr stores frequency of characters in current substring
        int[] frequencyArr = new int[26];

        int maxLength = 0;

        for (int start = 0; start < str.length(); start++) {
            for (int end = start; end < str.length(); end++) {
                // Include current character into substring
                frequencyArr[str.charAt(end) - 'A']++;

                int substringLength = end - start + 1;

                /*
                 Check if current substring can be converted into
                 all identical characters using at most k replacements.
                */
                if (!canFormRepeatingSubstring(frequencyArr, substringLength, k)) {
                    /*
                     IMPORTANT BREAK CONDITION
                    
                     If substring [start ... end] cannot be converted
                     into identical characters within k operations,
                     then any longer substring [start ... end+1], [start ... end+2]...
                    
                     will ALSO require >= same or more replacements.
                    
                     Reason:
                     Window length increases → mismatched characters either increase or stay same
                     Required replacements never decrease while expanding.
                    
                     Special case:
                     Replacements remain SAME only when the newly added character
                     is the same as the current most frequent character.
                     Even then, replacements do not reduce — they just stay constant.
                    
                     Therefore the substring will never become valid again.
                     So further expansion is useless → break inner loop.
                    */
                    break;
                }

                // Valid substring → update answer
                maxLength = Math.max(maxLength, substringLength);
            }

            // Reset frequency array for next starting index
            Arrays.fill(frequencyArr, 0);
        }

        return maxLength;
    }

    private boolean canFormRepeatingSubstring(int[] frequencyArr, int windowLength, int k) {
        /*
         Key Idea:
         To convert the whole substring into identical characters,
         we should convert everything into the MOST FREQUENT character.
        
         Why?
         Because that minimizes the number of replacements needed.
        */
        int maxFreq = getMaxFreq(frequencyArr);

        /*
         Number of characters that must be replaced =
         total characters - most frequent character count
        */
        int remainingChars = windowLength - maxFreq;

        /*
         If replacements needed <= k
         → substring can be made uniform
        */
        return remainingChars <= k;
    }

    private int getMaxFreq(int[] frequencyArr) {
        int maxFreq = 0;

        for (int i = 0; i < 26; i++) {
            /*
            If frequency is zero → character not present in substring
            So it cannot be the dominant character.
            Skip it for clarity of reasoning.
            */
            if (frequencyArr[i] == 0) {
                continue;
            }
            if (frequencyArr[i] > maxFreq) {
                maxFreq = frequencyArr[i];
            }
        }

        return maxFreq;
    }
}


//Better Approach

class Solution {
    public int characterReplacement(String str, int k) {
        /*
         freqArr[i] = how many times character ('A' + i)
         exists inside the CURRENT WINDOW
        */
        int[] freqArr = new int[26];

        int windowStart = 0;
        int windowEnd = 0;
        int maxLength = 0;

        while (windowEnd < str.length()) {
            // Expand window by including current character
            char ch = str.charAt(windowEnd);
            freqArr[ch - 'A']++;

            /*
             If current window cannot be converted into
             identical characters within k replacements,
             shrink window from the left.
            */
            while (!canFormRepeatingSubstring(freqArr, windowStart, windowEnd, k)) {
                freqArr[str.charAt(windowStart++) - 'A']--;
            }

            /*
             Now window is valid:
             we can convert this entire substring into
             same characters using <= k replacements
            */
            int substringLength = windowEnd - windowStart + 1;
            maxLength = Math.max(maxLength, substringLength);

            // Continue expanding window
            windowEnd++;
        }

        return maxLength;
    }

    private boolean canFormRepeatingSubstring(int[] freqArr, int windowStart, int windowEnd, int k) {
        int windowSize = windowEnd - windowStart + 1;
        /*
         To make all characters identical,
         best strategy is to convert everything
         into the MOST FREQUENT character.
        
         Required replacements = window size - frequency of dominant character
        */
        int maxFreq = getMaxFreq(freqArr);

        int replacementChars = windowSize - maxFreq;

        return replacementChars <= k;
    }

    private int getMaxFreq(int[] freqArr) {
        int maxFreq = 0;

        for (int val : freqArr) {
            if (val == 0) {
                continue;
            }
            maxFreq = Math.max(maxFreq, val);
        }

        return maxFreq;
    }
}


//Optimal Approach

/*
===============================================================================
LONGEST REPEATING CHARACTER REPLACEMENT — FULL CORRECT EXPLANATION
===============================================================================

Goal:
Find the longest substring that can be converted into identical characters
using at most k replacements.

For any window:

    replacementsNeeded = windowSize - MaxFreqInWindow

where:
MaxFreqInWindow = frequency of the most frequent character inside CURRENT window

Valid window condition:
    windowSize - MaxFreqInWindow <= k


===============================================================================
THE TRICK (WHY maxFreq IS NEVER DECREASED)
===============================================================================

We maintain:

    maxFreq = highest frequency EVER seen while expanding the window

Important:
maxFreq is NOT always equal to MaxFreqInWindow.
Sometimes it becomes stale (greater than actual frequency inside current window).

So:

    maxFreq >= MaxFreqInWindow


We shrink window while:

    windowSize - maxFreq > k

But mathematically correct shrinking condition should be:

    windowSize - MaxFreqInWindow > k


Since:

    maxFreq >= MaxFreqInWindow

⇒ windowSize - maxFreq <= windowSize - MaxFreqInWindow

Meaning:

Stale maxFreq delays shrinking but never shrink too early
We may temporarily keep an invalid window,
but we will never discard a potentially optimal window.
===============================================================================
WHY ANSWER REMAINS CORRECT
===============================================================================

Right pointer only moves forward.

If we record a window of length L:

Either:
1) Window is actually valid → correct

OR
2) Window became invalid due to stale maxFreq

But if case (2) happens,
then this same length must have appeared earlier when window was valid
during expansion phase.

===============================================================================
FULL DRY RUN
===============================================================================

String = "AABABBA"
k = 1

We track:
windowStart, windowEnd, maxFreq, windowSize, replacements

---------------------------------------------------------------------------
Step 1: Add 'A'
window = [A]
freq: A=1
maxFreq=1
size=1
replacements = 1-1 = 0 ✓ valid
maxLength=1

---------------------------------------------------------------------------
Step 2: Add 'A'
window = [AA]
freq: A=2
maxFreq=2
size=2
replacements = 2-2 = 0 ✓ valid
maxLength=2

---------------------------------------------------------------------------
Step 3: Add 'B'
window = [AAB]
freq: A=2 B=1
maxFreq=2
size=3
replacements = 3-2 = 1 ✓ valid
maxLength=3

---------------------------------------------------------------------------
Step 4: Add 'A'
window = [AABA]
freq: A=3 B=1
maxFreq=3
size=4
replacements = 4-3 = 1 ✓ valid
maxLength=4

---------------------------------------------------------------------------
Step 5: Add 'B'
window = [AABAB]
freq: A=3 B=2
maxFreq=3
size=5
replacements = 5-3 = 2 ✗ invalid → shrink

Remove left 'A'

window = [ABAB]
freq: A=2 B=2
MaxFreqInWindow=2
BUT maxFreq still = 3 (stale)

Algorithm check:
size=4
replacements = 4-3 = 1 ✓ accepts

REAL replacements = 4-2 = 2 ✗ invalid

We kept an invalid window,
BUT length 4 already existed as valid substring "AABA".

So answer still safe.

---------------------------------------------------------------------------
Step 6: Add 'B'
window = [ABABB]
freq: A=2 B=3
maxFreq=3
size=5
replacements = 5-3 = 2 ✗ shrink

Remove 'A'
window = [BABB]
freq: A=1 B=3
size=4
replacements = 4-3 = 1 ✓ valid
maxLength remains 4

---------------------------------------------------------------------------
Step 7: Add 'A'
window = [BABBA]
freq: A=2 B=3
maxFreq=3
size=5
replacements = 5-3 = 2 ✗ shrink

Remove 'B'
window = [ABBA]
freq: A=2 B=2
size=4
replacements = 4-3 = 1 ✓ accepted (stale again)

---------------------------------------------------------------------------
END

Maximum recorded length = 4
*/

class Solution {
    public int characterReplacement(String str, int k) {
        int[] freqArr = new int[26];

        int windowStart = 0;
        int windowEnd = 0;
        int maxLength = 0;
        int maxFreq = 0;

        while (windowEnd < str.length()) {
            char ch = str.charAt(windowEnd);
            freqArr[ch - 'A']++;
            maxFreq = Math.max(maxFreq, freqArr[ch - 'A']);

            while (!canFormRepeatingSubstring(windowStart, windowEnd, k, maxFreq)) {
                freqArr[str.charAt(windowStart++) - 'A']--;
            }

            int substringLength = windowEnd - windowStart + 1;
            maxLength = Math.max(maxLength, substringLength);
            windowEnd++;
        }

        return maxLength;
    }

    private boolean canFormRepeatingSubstring(int windowStart, int windowEnd, int k, int maxFreq) {
        int windowSize = windowEnd - windowStart + 1;
        int replacementChars = windowSize - maxFreq;
        return replacementChars <= k;
    }
}
