//Bruteforce Approach

class Solution {
    public int numberOfSubarrays(int[] arr, int k) {
        int windowOddCount = 0;
        int validSubarrayCount = 0;

        for (int start = 0; start < arr.length; start++) {
            for (int end = start; end < arr.length; end++) {
                // include current element
                if (arr[end] % 2 != 0) {
                    windowOddCount++;
                }

                // current subarray is valid → increment answer
                if (windowOddCount == k) {
                    validSubarrayCount++;
                }
                /*
                 If windowOddCount > k
                 → any longer subarray from the same start will also have > k odd numbers
                      because adding elements cannot remove existing odds
                      So no future extension can become valid again
                 → break early for this start index
                */
                if (windowOddCount > k) {
                    break;
                }
            }

            // reset for next starting index
            windowOddCount = 0;
        }

        return validSubarrayCount;
    }
}


//Optimal Approach

class Solution {
    /*
    COUNT SUBARRAYS WITH EXACTLY K ODD NUMBERS
    
    Direct sliding window for "exactly K" does NOT work.
    
    Why?
    
    Suppose current window has exactly K odd numbers:
    
       Expand right →
           odd count may stay K  (valid)
           OR become K+1 (invalid)
    
       Shrink left →
           odd count may stay K
           OR become K-1 (invalid)
    
    We cannot decide a consistent rule:
    - When should we shrink?
    - When should we expand?
    
    Condition is NON-MONOTONIC → sliding window breaks.
    
    ---------------------------------------------------------
    
    Instead we convert the problem:
    
       exactly(K) = atMost(K) - atMost(K-1)
    
    Because:
    
       atMost(K) odd number = subarrays with 0 odd + 1 odd + ... + K odd
    
       atMost(K-1) odd number = subarrays with 0 odd + 1 odd + ... + K-1 odd
    
    Subtract → leaves exactly K odd
    
    Now "at most K odd" IS monotonic:
       if oddCount > K → shrinking always fixes it
    
    So sliding window works.
    */
    public int numberOfSubarrays(int[] arr, int k) {
        return subarraysWithAtmostKOdd(arr, k) - subarraysWithAtmostKOdd(arr, k - 1);
    }

    private int subarraysWithAtmostKOdd(int[] arr, int k) {
        int windowStart = 0;
        int windowEnd = 0;
        int windowOddCount = 0;
        int validSubarrayCount = 0;

        while (windowEnd < arr.length) {
            // include new element
            if (arr[windowEnd] % 2 != 0) {
                windowOddCount++;
            }

            // shrink window if invalid
            while (!hasAtmostKOdds(windowOddCount, k)) {
                if (arr[windowStart] % 2 != 0) {
                    windowOddCount--;
                }
                windowStart++;
            }
            /*
            Window now has ≤ k odd numbers.
            
            All subarrays ending at 'windowEnd' and starting from
            indices [windowStart ... windowEnd] are valid.
            
            Count added = window length
            */
            int windowSize = windowEnd - windowStart + 1;
            validSubarrayCount += windowSize;
            windowEnd++;
        }

        return validSubarrayCount;
    }

    private boolean hasAtmostKOdds(int windowOddCount, int k) {
        return windowOddCount <= k;
    }
}
