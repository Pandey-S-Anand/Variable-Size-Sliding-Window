//Bruteforce Approach

class Solution {
    public int subarraysWithKDistinct(int[] arr) {
        Set<Integer> distinctChars = new HashSet<>();
        int validStringCount = 0;

        for (int start = 0; start < arr.length; start++) {
            for (int end = start; end < arr.length; end++) {
                // include current element in subarray
                distinctChars.add(arr[end]);

                // valid subarray with exactly k distinct
                if (distinctChars.size() == k) {
                    validStringCount++;
                }

                /*
                once distinct > k,
                extending further cannot fix it
                so stop checking larger windows from this start
                */
                if (distinctChars.size() > k) {
                    break;
                }
            }

            // reset for next starting index
            distinctChars.clear();
        }

        return validStringCount;
    }
}


//Optimal Approach

class Solution {
    /*    
    Directly counting subarrays with exactly K distinct elements
    using sliding window is difficult because the condition is NON-MONOTONIC.
    
    Suppose current window has exactly K distinct:
    
        Expand right →
            may remain K
            OR may become K+1 (invalid)
    
        Shrink left →
            may remain K
            OR may become K-1 (invalid)
    
    We cannot decide a consistent direction.
    So window cannot be maintained reliably.
    
    --------------------------------------------------------------------
    
    Instead we transform the problem:
    
        exactly(K) = atMost(K) - atMost(K-1)
    
    Because:
    
        atMost(K)
        = exactly(1) + exactly(2) + ... + exactly(K)
    
        atMost(K-1)
        = exactly(1) + exactly(2) + ... + exactly(K-1)
    
    Subtracting cancels smaller cases → leaves exactly(K)
    
    --------------------------------------------------------------------
    
    Now "at most K distinct" IS monotonic:
    
        If distinct > K → shrink left → always fixes window
    
    So sliding window works perfectly.
    */
    public int subarraysWithKDistinct(int[] arr, int k) {
        return subarraysWithAtmostKDistinct(arr, k) - subarraysWithAtmostKDistinct(arr, k - 1);
    }

    private int subarraysWithAtmostKDistinct(int[] arr, int k) {
        Map<Integer, Integer> freqMap = new HashMap<>();

        int windowStart = 0;
        int windowEnd = 0;
        int validSubarrayCount = 0;

        while (windowEnd < arr.length) {
            // include new element
            freqMap.put(arr[windowEnd], freqMap.getOrDefault(arr[windowEnd], 0) + 1);

            // shrink if distinct elements exceed k
            while (freqMap.size() > k) {
                freqMap.put(arr[windowStart], freqMap.get(arr[windowStart]) - 1);

                if (freqMap.get(arr[windowStart]) == 0) {
                    freqMap.remove(arr[windowStart]);
                }

                windowStart++;
            }

            /*
            Window now has ≤ k distinct elements
            
            All subarrays ending at windowEnd and starting from
            [windowStart ... windowEnd] are valid
            */
            validSubarrayCount += (windowEnd - windowStart + 1);

            windowEnd++;
        }

        return validSubarrayCount;
    }
}
