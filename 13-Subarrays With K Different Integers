//Bruteforce Approach

class Solution {
    public int subarraysWithKDistinct(int[] arr, int k) {
        Set<Integer> distinctChars = new HashSet<>();
        int validStringCount = 0;

        for (int start = 0; start < arr.length; start++) {
            for (int end = start; end < arr.length; end++) {
                // include current element in subarray
                distinctChars.add(arr[end]);

                // valid subarray with exactly k distinct
                if (distinctChars.size() == k) {
                    validStringCount++;
                }

                /*
                once distinct > k,
                extending further cannot fix it
                so stop checking larger windows from this start
                */
                if (distinctChars.size() > k) {
                    break;
                }
            }

            // reset for next starting index
            distinctChars.clear();
        }

        return validStringCount;
    }
}



//Optimal Approach

/*    
  Directly counting subarrays with exactly K distinct elements
  using sliding window is difficult because the condition is NON-MONOTONIC.

  Suppose current window has exactly K distinct:

    Expand right →
        may remain K
        OR may become K+1 (invalid)

    Shrink left →
        may remain K
        OR may become K-1 (invalid)

  We cannot decide a consistent direction.
  So window cannot be maintained reliably.

--------------------------------------------------------------------

Instead we transform the problem:

    exactly(K) = atMost(K) - atMost(K-1)

Because:

    atMost(K)  = exactly(1) distinct + exactly(2) distinct + ... + exactly(K) distinct

    atMost(K-1) = exactly(1) distinct + exactly(2) distinct + ... + exactly(K-1) distinct

Subtracting cancels smaller cases → leaves exactly(K)

--------------------------------------------------------------------

Now "at most K distinct" IS monotonic:

    If distinct > K → shrink left → always fixes window

So sliding window works perfectly.
*/
class Solution {
    public int subarraysWithKDistinct(int[] arr, int k) {
        return countSubarrayAtMostKDistinct(arr, k) - countSubarrayAtMostKDistinct(arr, k - 1);
    }

    private int countSubarrayAtMostKDistinct(int[] arr, int k) {
        Map<Integer, Integer> windowFreqMap = new HashMap<>();

        int windowStart = 0;
        int windowEnd = 0;
        int substringsAtMostKDistinct = 0;

        while (windowEnd < arr.length) {
            // include current character
            windowFreqMap.put(arr[windowEnd], windowFreqMap.getOrDefault(arr[windowEnd], 0) + 1);

            /*
            If distinct characters exceed k,
            shrink window until constraint restored
            */
            while (!hasAtMostKDistinct(windowFreqMap, k)) {
                windowFreqMap.put(arr[windowStart], windowFreqMap.get(arr[windowStart]) - 1);
                if (windowFreqMap.get(arr[windowStart]) == 0) {
                    windowFreqMap.remove(arr[windowStart]);
                }
                windowStart++;
            }

            /*
            At this point window is valid (≤ k distinct)
            
            Now comes the most important observation:
            
            All substrings ending at windowEnd and starting
            from any index between [windowStart ... windowEnd]
            are valid.
            
            Example:
                window = [start ... end]
            
                Valid substrings ending at end:
                end
                end-1..end
                end-2..end
                ...
                start..end
            
            Count = window length = windowEnd - windowStart + 1
            */
            int windowSize = windowEnd - windowStart + 1;
            substringsAtMostKDistinct += windowSize;
            windowEnd++;
        }

        return substringsAtMostKDistinct;
    }

    private boolean hasAtMostKDistinct(Map<Integer, Integer> windowFreqMap, int k) {
        return windowFreqMap.size() <= k;
    }
}
