//Bruteforce Approach

class Solution {
    /*
    Goal:
    Count all subarrays whose product < k.
    
    For each starting index:
        expand the subarray to the right
        maintain running product
        stop expansion once product ≥ k
    
    ---------------------------------------------------------------------------
    WHY BREAK IS CORRECT
    
    All array elements are positive (arr[i] ≥ 1)
    
    So when we extend the subarray:
        product only increases (or stays same if 1)
    
    Once product ≥ k,
    any longer subarray from the same start index will
    also have product ≥ k.
    
    Therefore no future end positions can be valid,
    and we safely break early.
    ===========================================================================
    */

    public int numSubarrayProductLessThanK(int[] arr, int k) {
        int subarrayCount = 0;
        int subarrayProduct = 1;

        for (int start = 0; start < arr.length; start++) {
            for (int end = start; end < arr.length; end++) {
                // include current element
                subarrayProduct *= arr[end];

                // once invalid, further expansion cannot fix it
                if (subarrayProduct >= k) {
                    break;
                }

                // valid subarray
                subarrayCount++;
            }

            // reset for next start index
            subarrayProduct = 1;
        }

        return subarrayCount;
    }
}



//Optimal Approach

class Solution {
    /*    
    Goal:
    Count number of contiguous subarrays whose product < k
    
    Key Property:
    All numbers are positive (1 ≤ arr[i] ≤ 1000)
    
    So:
    - Expanding window → product increases
    - Shrinking window → product decreases
    
    Hence sliding window works (monotonic behavior)
    
    ---------------------------------------------------------------------------
    ===============================================================================
    IMPORTANT EDGE CASE
    ===============================================================================
    
    As per problem constraints:
    0 <= k <= 10^6
    and 1 <= arr[i]
    
    If k <= 1:
    No valid subarray can exist.
    
    Reason:
    
    The smallest possible product of any non-empty subarray is 1
    (because every element in the array is ≥ 1).
    
    So the product of any subarray can never be:
    < 1
    
    Therefore:
    If k is 0 or 1,
    it is impossible to find a subarray whose product is strictly less than k.
    
    Hence, the answer must be 0.
    
    ===========================================================================
    */
    public int numSubarrayProductLessThanK(int[] arr, int k) {
        // No product of positive integers can be < 1
        if (k <= 1) {
            return 0;
        }

        int windowStart = 0;
        int windowEnd = 0;
        int windowProduct = 1;
        int subarrayCount = 0;

        while (windowEnd < arr.length) {
            // expand window
            windowProduct *= arr[windowEnd];

            // shrink until product becomes valid
            while (!isProductLessThanK(windowProduct, k)) {
                windowProduct /= arr[windowStart];
                windowStart++;
            }

            /*
             Now windowProduct < k
            
             All subarrays ending at windowEnd are valid:
             [start...end], [start+1...end], ... [end...end]
            
             Number of such subarrays = window size
            */
            int windowSize = windowEnd - windowStart + 1;
            subarrayCount += windowSize;

            windowEnd++;
        }

        return subarrayCount;
    }

    private boolean isProductLessThanK(int windowProduct, int k) {
        return windowProduct < k;
    }
}
