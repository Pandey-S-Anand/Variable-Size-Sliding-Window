//Bruterforce Approach

class Solution {
    /*
    INTUITION
    
    A string is balanced when every character appears exactly n/4 times.
    
    If some characters exceed n/4,
    it means those extra characters are occupying the slots
    that should have been used by other required characters.
    
    In other words:
    These excess characters are the reason the string is unbalanced.
    
    So if we can find a minimum-length substring that contains
    ALL the extra characters, we can replace that substring
    with the required characters in correct proportion.
    
    Once we remove (replace) all excess characters with the required chars,
    the remaining part of the string automatically satisfies
    the balanced condition.
    
    Therefore, the problem reduces to:
    
    "Find the minimum window that covers all excess characters."
    
    NOTE:
    
    Minimum window does NOT necessarily contain only extra characters.
    
    Example:
    s = "QEQEQWQWWQRQ"
    n = 12
    requiredFreq = 3
    
    Q = 6 → 3 extra
    W = 3
    E = 2
    R = 1
    
    We must cover 3 Q’s.
    
    One possible minimal window:
    "QEQEQ"
    
    This window contains:
    Q = 3 (required extra)
    E = 2 (not extra)
    
    So window may include non-extra characters
    if extra characters are interleaved.
    
    Condition is NOT:
    "window contains only extra characters"
    
    Condition is:
    "window contains at least all extra characters"
    */
    public int balancedString(String str) {
        int requiredFreq = str.length() / 4;

        // freqArr → stores total frequency of each character
        int[] freqArr = new int[26];

        // extraChars → stores how many extra occurrences must be covered
        int[] extraChars = new int[26];

        boolean alreadyBalanced = true;

        /*
        Count total frequencies.
        If any character exceeds requiredFreq,
        mark the extra count in extraChars.
        */
        for (int i = 0; i < str.length(); i++) {
            int idx = str.charAt(i) - 'A';
            freqArr[idx]++;

            if (freqArr[idx] > requiredFreq) {
                extraChars[idx]++;
                alreadyBalanced = false;
            }
        }

        // If no character exceeded required frequency, string is already balanced.
        if (alreadyBalanced) {
            return 0;
        }

        int minWindowLength = Integer.MAX_VALUE;

        /*
        Try every possible substring.
        For each (start, end), check if it covers all extra characters.
        */
        for (int start = 0; start < str.length(); start++) {
            for (int end = start; end < str.length(); end++) {
                /*
                We DO NOT break once we find a valid window.
                
                Reason:
                
                Although current window works,
                there may exist a smaller valid window
                starting from a later index.
                
                Example:
                str = "WQQQ"
                
                freq:
                W = 1
                Q = 3
                
                requiredFreq = 1 (since n = 4)
                
                Extra characters:
                Q has 2 extra occurrences.
                
                When start = 0:
                    window [0..2] = "WQQ" → valid (length 3)
                
                But when start = 1:
                    window [1..2] = "QQ" → valid (length 2)
                
                This smaller window covers all extra Q's.
                
                If we replace "QQ" with "ER",
                the string becomes balanced:
                W E R Q  (each appears once)
                
                So if we stopped at the first valid window,
                we would miss a smaller valid answer.
                
                Hence we must continue exploring all possibilities.
                */
                if (coversAllExtras(str, start, end, extraChars)) {
                    int windowLength = end - start + 1;
                    minWindowLength = Math.min(minWindowLength, windowLength);
                }
            }
        }

        return minWindowLength;
    }

    /*
    Checks whether substring [startIdx, endIdx]
    contains all required extra characters.
    
    We clone extraChars to avoid modifying original requirement.
    Then we reduce counts as we see matching characters in window.
    If after scanning window any extra > 0 remains,
    window does NOT fully cover required excess.
    */
    private boolean coversAllExtras(String str, int startIdx, int endIdx, int[] extraChars) {
        // clone to avoid modifying original 'extraChars'
        extraChars = extraChars.clone();

        // reduce required extras using characters in window
        for (int i = startIdx; i <= endIdx; i++) {
            int idx = str.charAt(i) - 'A';

            if (extraChars[idx] > 0) {
                extraChars[idx]--;
            }
        }

        // verify if all required extras are satisfied
        for (int freq : extraChars) {
            if (freq > 0) {
                return false;
            }
        }

        return true;
    }
}



//Optimal Approach

class Solution {
    /*
    CORE IDEA (Switch in Thinking)
    
    Instead of finding a window that directly contains all extra characters,
    we maintain frequencies of characters OUTSIDE the window.
    
    Key Identity:
       totalFrequency = outsideFrequency + insideFrequency
    
    Meaning:
    If no character outside the window exceeds the required limit,
    then all extra characters must already be inside the window.
    
    Therefore:
    Window = substring we will replace
    Outside = part that must not contain any excess characters
    
    Once outside is valid (no extra chars outside) i.e extra chars are inside the window,
    we try to shrink the window to get minimum length.
    */
    public int balancedString(String str) {
        int reqFreq = str.length() / 4;

        int[] freqArr = new int[26];

        // Count total frequencies
        for (int i = 0; i < str.length(); i++) {
            freqArr[str.charAt(i) - 'A']++;
        }
        
        // If already balanced → no replacement needed
        if (freqArr['Q' - 'A'] == reqFreq && freqArr['W' - 'A'] == reqFreq && freqArr['E' - 'A'] == reqFreq && freqArr['R' - 'A'] == reqFreq) {
            return 0;
        }

        int windowStart = 0;
        int windowEnd = 0;
        int minWindowLength = Integer.MAX_VALUE;

        while (windowEnd < str.length()) {
            /*
            Expand window:
            Remove current character from outside
            (i.e include it in window)
            */
            freqArr[str.charAt(windowEnd) - 'A']--;
            /*
            If outside has no extra characters,
            it means all extra characters are inside window.
            
            Why?
            totalFreq = outsideFreq + insideFreq
            
            If outsideFreq <= requiredFreq
            then insideFreq must contain the surplus.
            */
            while (hasNoExcessOutside(freqArr, reqFreq)) {
                // current window is valid → update answer
                int windowLength = windowEnd - windowStart + 1;
                minWindowLength = Math.min(minWindowLength, windowLength);
                /*
                Try shrinking to get smaller valid window.
                Shrinking means moving a character back to outside.
                This may break validity.
                */
                freqArr[str.charAt(windowStart) - 'A']++;
                windowStart++;
            }
            windowEnd++;
        }

        return minWindowLength;
    }

    /*
    Outside is valid when no character exceeds required frequency.
    This ensures no extra characters remain outside the window.
    */
    private boolean hasNoExcessOutside(int[] freqArr, int reqFreq) {
        return freqArr['Q' - 'A'] <= reqFreq && freqArr['W' - 'A'] <= reqFreq && freqArr['E' - 'A'] <= reqFreq && freqArr['R' - 'A'] <= reqFreq;
    }
}
