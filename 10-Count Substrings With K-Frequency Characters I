//Bruteforce Approach

class Solution {
    public int numberOfSubstrings(String str, int k) {
        int validSubstringCount = 0;
        int[] windowFreqArr = new int[26];

        for (int start = 0; start < str.length(); start++) {

            for (int end = start; end < str.length(); end++) {

                // include current character
                windowFreqArr[str.charAt(end) - 'a']++;

                /*
                As soon as a character frequency becomes ≥ k,
                the current substring AND all longer substrings
                starting at the same index will also be valid.
                
                Why?
                Because adding more characters can only increase frequencies,
                never decrease them.
                
                So instead of checking all longer substrings one by one,
                we count them in one step.
                
                All substrings:
                    [start ... end]
                    [start ... end+1]
                    [start ... end+2]
                    ...
                    [start ... n-1]
                
                are also valid.
                
                Count = remaining length = n - end
                */
                if (hasCharFreqAtLeastK(windowFreqArr, k)) {
                    validSubstringCount += (str.length() - end);
                    break; // no need to extend further for this start
                }
            }

            // reset frequency for next start index
            Arrays.fill(windowFreqArr, 0);
        }

        return validSubstringCount;
    }

    // returns true if any character appears ≥ k times
    private boolean hasCharFreqAtLeastK(int[] windowFreqArr, int k) {
        for (int freq : windowFreqArr) {
            if (freq >= k) {
                return true;
            }
        }
        return false;
    }
}


//Better Approach

class Solution {
    /*
    PROBLEM INTUITION
    
    We need substrings where: at least one character frequency ≥ k
    ------------------------------------------------------------------
    
    Why normal sliding window does NOT work directly?
    
    Sliding window works when validity is monotonic:
        invalid → shrink fixes it
        valid   → expand keeps it valid
    
    But here validity is NON-MONOTONIC.
    
    Suppose current window already has a character with freq ≥ k.
    Now what should we do?
    
        Expand right?
            Might remain valid
            But we may skip smaller valid substrings starting later
    
        Shrink left?
            Might break the only character that had freq ≥ k
    
    So we cannot decide a consistent direction.
    
    → This breaks standard sliding window reasoning.
    ------------------------------------------------------------------
    
    So we count the complement instead.
    
    Instead of counting:
        substrings where ANY char freq ≥ k
    
    We count:
        substrings where ALL char freq < k   (BAD substrings)
    
    This condition IS monotonic:
        If any char reaches k → window invalid
        Shrink until all freq < k again
    
    Finally:
    
        answer = total substrings - bad substrings
    */

    public int numberOfSubstrings(String str, int k) {
        int[] windowFreqArr = new int[26];
        int windowStart = 0;
        int windowEnd = 0;
        int badStrings = 0;

        while (windowEnd < str.length()) {
            // include right character
            windowFreqArr[str.charAt(windowEnd) - 'a']++;

            /*
            If any character frequency becomes ≥ k,
            window is no longer a "bad substring".
            So shrink until all frequencies < k again.
            */
            while (!isWindowWithinKFreqLimit(windowFreqArr, k)) {
                windowFreqArr[str.charAt(windowStart++) - 'a']--;
            }

            /*
            Now window contains only characters with freq < k
            
            All substrings ending at windowEnd and starting from
            [windowStart ... windowEnd] are bad substrings.
            
            Count = window length
            */
            badStrings += (windowEnd - windowStart + 1);
            windowEnd++;
        }

        // total substrings in string
        int totalSubstrings = (str.length() * (str.length() + 1)) / 2;

        // subtract bad substrings to get required substrings
        return totalSubstrings - badStrings;
    }

    // returns true if ANY character frequency ≥ k
    private boolean isWindowWithinKFreqLimit(int[] windowFreqArr, int k) {
        for (int freq : windowFreqArr) {
            if (freq != 0 && freq >= k) {
                return false;
            }
        }
        return true;
    }
}


//Optimal Approach

class Solution {
    public int numberOfSubstrings(String str, int k) {
        int[] windowFreqArr = new int[26];
        int windowStart = 0;
        int windowEnd = 0;
        int badStrings = 0;

        // tracks if any character currently violates (freq >= k)
        char violatingChar = Character.MIN_VALUE;

        while (windowEnd < str.length()) {
            windowFreqArr[str.charAt(windowEnd) - 'a']++;

            /*
             If any character frequency becomes exactly k,
             this window is no longer a "bad" window.
             
             It now satisfies:
                 at least one char freq ≥ k
             
             So we mark it as violating.
             */
            if (windowFreqArr[str.charAt(windowEnd) - 'a'] == k) {
                violatingChar = str.charAt(windowEnd);
            }

            while (!isWindowWithinKFreqLimit(violatingChar)) {
                windowFreqArr[str.charAt(windowStart) - 'a']--;

                /*
                 If we remove the violating character,
                 then the violation disappears.
                 
                 After this removal, all frequencies are < k again.
                 */
                if (str.charAt(windowStart) == violatingChar) {
                    violatingChar = Character.MIN_VALUE;
                }
                windowStart++;
            }

            badStrings += (windowEnd - windowStart + 1);
            windowEnd++;
        }

        int totalSubstrings = (str.length() * (str.length() + 1)) / 2;

        return totalSubstrings - badStrings;
    }

    private boolean isWindowWithinKFreqLimit(char violatingChar) {
        return violatingChar == Character.MIN_VALUE;
    }
}
