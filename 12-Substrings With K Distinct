/*
WHY:
exactlyKDistinct = atMost(K) - atMost(K-1)

Key Idea:
Counting substrings with exactly K distinct characters directly is hard.
Instead, we count a bigger group and subtract the unwanted part.

--------------------------------------------------------------------

Think in terms of sets:

Substrings with at most K distinct =
    exactly 1 distinct
  + exactly 2 distinct
  + ...
  + exactly (K-1) distinct
  + exactly K distinct

Substrings with at most (K-1) distinct =
    exactly 1 distinct
  + exactly 2 distinct
  + ...
  + exactly (K-1) distinct

Subtracting:

atMost(K) - atMost(K-1) = exactly K distinct

All smaller cases cancel out.

---------------------------------
Why sliding window?

"Exactly K distinct" is NOT monotonic:
- adding a character may break validity
- removing a character may also break validity

But "At most K distinct" IS monotonic:
we only shrink when distinct > K

So we transform the hard condition into two easy sliding window problems:

exactly(K) = atMost(K) - atMost(K-1)
*/

//Bruteforce Approach

class Solution {
    public int countSubstr(String str, int k) {
        Set<Character> distinctChars = new HashSet<>();
        int substringsWithKDistinct = 0;

        for (int start = 0; start < str.length(); start++) {
            for (int end = start; end < str.length(); end++) {
                distinctChars.add(str.charAt(end));
                if (distinctChars.size() > k) {
                    break;
                }
                if (distinctChars.size() == k) {
                    substringsWithKDistinct++;
                }
            }
            distinctChars.clear();
        }

        return substringsWithKDistinct;
    }
}


//Improved Approach

class Solution {
    public int countSubstr(String str, int k) {
        return countSubstringAtMostKDistinct(str, k) - countSubstringAtMostKDistinct(str, k - 1);
    }

    private int countSubstringAtMostKDistinct(String str, int k) {
        Map<Character, Integer> windowFreqMap = new HashMap<>();

        int windowStart = 0;
        int windowEnd = 0;
        int substringsAtMostKDistinct = 0;

        while (windowEnd < str.length()) {
            // include current character
            char incomingChar = str.charAt(windowEnd);
            windowFreqMap.put(incomingChar, windowFreqMap.getOrDefault(incomingChar, 0) + 1);

            /*
            If distinct characters exceed k,
            shrink window until constraint restored
            */
            while (!hasAtMostKDistinct(windowFreqMap, k)) {
                char outgoingChar = str.charAt(windowStart++);
                windowFreqMap.put(outgoingChar, windowFreqMap.get(outgoingChar) - 1);

                if (windowFreqMap.get(outgoingChar) == 0) {
                    windowFreqMap.remove(outgoingChar);
                }
            }

            /*
            At this point window is valid (≤ k distinct)
            
            Now comes the most important observation:
            
            All substrings ending at windowEnd and starting
            from any index between [windowStart ... windowEnd]
            are valid.
            
            Example:
                window = [start ... end]
            
                Valid substrings ending at end:
                end
                end-1..end
                end-2..end
                ...
                start..end
            
            Count = window length = windowEnd - windowStart + 1
            */
            int windowSize = windowEnd - windowStart + 1;
            substringsAtMostKDistinct += windowSize;
            windowEnd++;
        }

        return substringsAtMostKDistinct;
    }

    private boolean hasAtMostKDistinct(Map<Character, Integer> windowFreqMap, int k) {
        return windowFreqMap.size() <= k;
    }
}


//Better Approach

class Solution {
    public int countSubstr(String str, int k) {
        return countSubstringAtMostKDistinct(str, k) - countSubstringAtMostKDistinct(str, k - 1);
    }

    private int countSubstringAtMostKDistinct(String str, int k) {
        int[] windowFreqArr = new int[26]; // frequency of characters in current window
        int windowStart = 0;
        int windowEnd = 0;

        int substringsAtMostKDistinct = 0;

        while (windowEnd < str.length()) {
            // include new character into window
            windowFreqArr[str.charAt(windowEnd) - 'a']++;

            /*
            If distinct characters exceed k,
            shrink window until it becomes valid again.
            */
            while (!hasAtMostKDistinct(windowFreqArr, k)) {
                windowFreqArr[str.charAt(windowStart++) - 'a']--;
            }

            int windowSize = windowEnd - windowStart + 1;
            substringsAtMostKDistinct += windowSize;

            windowEnd++;
        }

        return substringsAtMostKDistinct;
    }

    /*
    Returns true if current window has at most k distinct characters.
    We count distinct characters by checking how many frequencies are non-zero.
    */
    private boolean hasAtMostKDistinct(int[] windowFreqArr, int k) {
        int distinctChars = 0;

        for (int i = 0; i < 26; i++) {
            if (windowFreqArr[i] != 0) {
                distinctChars++;

                if (distinctChars > k) {
                    return false;
                }
            }
        }

        return true;
    }
}


//Optimal Approach

class Solution {
    public int countSubstr(String str, int k) {
        return countSubstringAtMostKDistinct(str, k) - countSubstringAtMostKDistinct(str, k - 1);
    }

    /*
    We maintain distinctCharsInWindow manually instead of scanning the whole
    frequency array every time.
    
    Key observation:
    - If windowFreqArr[idx] was 0 before adding a character → it is a NEW distinct char
    - If windowFreqArr[idx] becomes 0 after removing a character → that distinct char disappears
    
    So frequency transitions help us track distinct count in O(1).
    */
    private int countSubstringAtMostKDistinct(String str, int k) {
        int[] windowFreqArr = new int[26]; // frequency inside current window
        int windowStart = 0;
        int windowEnd = 0;

        int substringsAtMostKDistinct = 0;
        int distinctCharsInWindow = 0; // number of distinct chars in window

        while (windowEnd < str.length()) {
            // add new character to window
            int idx = str.charAt(windowEnd) - 'a';
            if (windowFreqArr[idx] == 0) { // new distinct character enters
                distinctCharsInWindow++;
            }
            windowFreqArr[idx]++;

            while (!hasAtMostKDistinct(distinctCharsInWindow, k)) {
                idx = str.charAt(windowStart++) - 'a';
                windowFreqArr[idx]--;
                if (windowFreqArr[idx] == 0) { // character fully removed
                    distinctCharsInWindow--;
                }
            }

            int windowSize = windowEnd - windowStart + 1;
            substringsAtMostKDistinct += windowSize;

            windowEnd++;
        }

        return substringsAtMostKDistinct;
    }

    // validity check using maintained distinct count
    private boolean hasAtMostKDistinct(int distinctCharsInWindow, int k) {
        return distinctCharsInWindow <= k;
    }
}
